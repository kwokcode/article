
![日晷](https://upload-images.jianshu.io/upload_images/15063932-53fbcf6e8d5eb703.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

# 进程(process):
狭义定义：进程就是一段程序的执行过程例如启动的某个app。
广义定义：进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中,进程即是基本的分配单元，也是基本的执行单元。

1）进程是一个实体，每个进程都有自己的地址空间，一般情况下，包含文本区域、数据区域、堆栈
2）进程是执行中的程序，程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称之为进程
3）进程本身不会运行，是线程的容器。线程不能单独执行，必须组成进程
4）一个程序至少有一个进程，一个进程至少有一个线程
5）对于操作系统来讲，一个任务就是一个进程，比如开一个浏览器就是启动一个浏览器进程。打开一款app就是打开一个进程，例如打开香哈就是运行了一个进程。
6）有些进程还不止同时做一件事情。比如打开香哈，它可以同时进行看视频并且回复用户评论，在一个进程内部，要同时干多件事情。


###进程状态：（三状态）

1. 就绪：获取出CPU外的所有资源、只要处理器分配资源就可以马上执行
2. 运行：获得处理器分配的资源，程序开始执行
3. 阻塞：当程序条件不够的时候，需要等待提交满足的时候才能执行。

![三状态](https://upload-images.jianshu.io/upload_images/15063932-cd5a5453ddaa871a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


###进程状态：（五态模型）对于一个实际的系统，进程的状态及其转换更为复杂。引入新建态和终止态构成了进程的五态模型。

1. 创建状态：进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态
2. 就绪状态：进程已经准备好，已分配到所需资源，只要分配到CPU就能够立即运行
3. 执行状态：进程处于就绪状态被调度后，进程进入执行状态
4. 阻塞状态：正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到阻塞。在满足请求时进入就绪状态等待系统调用
5. 终止状态：进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行

![五状态](https://upload-images.jianshu.io/upload_images/15063932-ba6bda321f8b7218.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)




# 线程：
1）一个进程中至少有一个线程，不然就没有存在的意义
2）在一个进程内部，要同时干多件事情，就需要同时运行多个子任务，我们把进程内的这些子任务叫做线程
3）多线程就是为了同步完成多项任务(在单个程序中同时运行多个线程完成不同的任务和工作)，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率 
4）一个简单的比喻，多线程就像是火车上的每节车厢，而进程就是火车 
5）线程是程序执行流的最小单元。一个标准的线程由当前的线程ID、当前指令指针、寄存器和堆栈组成 
6）同一个进程中的多个线程之间可以并发执行 


线程状态：
1）就绪：指线程具备运行的所有条件，逻辑上可以运行，在等待处理机 
2）运行：指线程占用处理机正在运行 
3）阻塞：线程在等待一个事件，逻辑上不可执行 


如果我们要同时执行多个任务怎么办？ 
1）启动多个进程，每个进程虽然只有一个线程，但是多个进程可以一块执行多个任务 
2）启动一个进程，在一个进程内启动多个线程，这样多个线程也可以一块执行多个任务 


多任务：
1）一边浏览网页、一边听歌、一边看电影；这就是多任务。 
![进程和线程关系](https://upload-images.jianshu.io/upload_images/15063932-2ecbe3a102b06489.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



#协程：
协程是一种用户态的轻量级线程，协程的调度完全由用户控制（进程和线程都是由cpu 内核进行调度）。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。
对于 进程、线程，都是有内核进行调度，有 CPU 时间片的概念，进行 抢占式调度（有多种调度算法）
    对于 协程(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程/线程，通常只能进行 协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。
    
# **goroutine 和协程区别**

　本质上，goroutine 就是协程。 不同的是，Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程。Golang 的一大特色就是从语言层面原生支持协程，在函数或者方法前面加 go关键字就可创建一个协程。

其他方面的比较
1. 内存消耗方面
    每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少。
    goroutine：2KB（官方）
    线程：8MB（参考网络）

2. 线程和 goroutine 切换调度开销方面
    线程/goroutine 切换开销方面，goroutine 远比线程小
    线程：涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP...等寄存器的刷新等。
    goroutine：只有三个寄存器的值修改 - PC / SP / DX.

![Golang](https://upload-images.jianshu.io/upload_images/15063932-f570e4b4fe3b7180.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
